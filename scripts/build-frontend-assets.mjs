/**
 * Trace:
 *   spec_id: SPEC-web-dashboard-1
 *   task_id: TASK-031
 */
import { promises as fs } from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');
const distDir = path.join(projectRoot, 'frontend', 'dist');
const outputFile = path.join(projectRoot, 'src', 'static', 'assets.ts');

async function main() {
  await verifyDistExists();
  const files = await collectFiles(distDir);
  if (files.length === 0) {
    throw new Error('No frontend build artifacts found. Run `npm -w frontend run build` first.');
  }

  const assetMapEntries = await Promise.all(
    files.map(async filePath => {
      const relativePath = path.relative(distDir, filePath).replaceAll(path.sep, '/');
      const routePath = relativePath === 'index.html' ? '/' : `/${relativePath}`;

      const buffer = await fs.readFile(filePath);
      const base64 = buffer.toString('base64');
      const etag = `"${crypto.createHash('sha1').update(buffer).digest('hex')}"`;
      const ext = path.extname(filePath).toLowerCase();

      return [
        routePath,
        {
          base64,
          contentType: getContentType(ext),
          etag,
          cacheControl: getCacheControl(routePath, ext),
        },
      ];
    })
  );

  // Sort routes for deterministic output
  assetMapEntries.sort(([a], [b]) => a.localeCompare(b));

  const serialized = assetMapEntries
    .map(([route, asset]) => {
      const pretty = JSON.stringify(asset, null, 2).replace(/\n/g, '\n    ');
      return `  ${JSON.stringify(route)}: ${pretty}`;
    })
    .join(',\n');

  const banner = `/**\n * AUTO-GENERATED FILE. DO NOT EDIT DIRECTLY.\n * Generated by scripts/build-frontend-assets.mjs\n *\n * Trace:\n *   spec_id: SPEC-web-dashboard-1\n *   task_id: TASK-031\n */`;

  const fileContents = `${banner}\n\nimport type { AssetMap } from './types.js';\n\nexport const STATIC_ASSETS: AssetMap = {\n${serialized}\n};\n\nexport type StaticAssetPath = keyof typeof STATIC_ASSETS;\n`;

  await fs.mkdir(path.dirname(outputFile), { recursive: true });
  await fs.writeFile(outputFile, fileContents, 'utf8');
  console.log(`Embedded ${assetMapEntries.length} frontend assets into src/static/assets.ts`);
}

async function verifyDistExists() {
  try {
    await fs.access(distDir);
  } catch (error) {
    throw new Error(`Missing frontend dist directory at ${distDir}. Run the frontend build first.`);
  }
}

async function collectFiles(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = await Promise.all(
    entries.map(async entry => {
      const entryPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        return collectFiles(entryPath);
      }

      if (entry.name.startsWith('.')) {
        return [];
      }

      return [entryPath];
    })
  );

  return files.flat();
}

function getContentType(ext) {
  switch (ext) {
    case '.html':
      return 'text/html; charset=utf-8';
    case '.js':
      return 'application/javascript';
    case '.css':
      return 'text/css';
    case '.svg':
      return 'image/svg+xml';
    case '.json':
      return 'application/json';
    case '.png':
      return 'image/png';
    case '.ico':
      return 'image/x-icon';
    case '.txt':
      return 'text/plain; charset=utf-8';
    case '.woff2':
      return 'font/woff2';
    default:
      return 'application/octet-stream';
  }
}

function getCacheControl(routePath, ext) {
  if (routePath === '/' || ext === '.html') {
    return 'no-cache, must-revalidate';
  }

  return 'public, max-age=31536000, immutable';
}

main().catch(error => {
  console.error(error);
  process.exitCode = 1;
});
